## Algorithm
桶排序：<br>
有一份考试分数结果[5,3,5,2,8]<br>
按照考试成绩排序，并且打印出来
```java
        //0-10分的桶
        int[] bucket = new int[10];
        //考试分数
        int[] score = new int[]{5,3,5,2,8,4,7,6};
        System.out.println("一个乱七八糟的考试成绩=========" + Arrays.toString(score));
        for (int i = 0; i < score.length; i++) {
            int bucketIndex = score[i];
            //根据分数结果，在成绩桶上进行++
            bucket[bucketIndex - 1] = bucket[bucketIndex - 1] + 1;
        }
        System.out.println("升序分割线=====================");
        //结果升序
        for (int i = 0; i < bucket.length; i++) {
            int people = bucket[i];
            if(people != 0){
                //按照人数打印
                for(int j = 0; j < people; j++){
                    System.out.println("test score : " + (i + 1));
                }
            }
        }
        System.out.println("降序分割线=====================");
        //结果降序
        for(int i = bucket.length - 1; i > 0; i--){
            int people = bucket[i];
            if(people != 0){
                for(int j = 0; j < people; j++){
                    System.out.println("test score : " + (i + 1));
                }
            }
        }
```

## Review
https://about.sourcegraph.com/go/gophercon-2018-binary-search-tree-algorithms/
这篇文章以GO语言实现为例，介绍二叉树算法

## Tip
优先使用Java类库提供的标准异常，而不是自定义异常，原因如下：<br>
1. Java平台提供满足绝大多数API需要抛出的异常
1. 重用Java平台的现有异常有很多好处，他使你提供的服务更加容易理解和使用
1. 异常类越少，内存footprint就越小，装在类的开销时间也就越少

## Share
《未来简史》<br>
20世纪末期，资本主义之所以胜出，赢得冷战，是因为至少在这个科技加速改变的时期，分散式数据处理的效果就是比集中式处理更好，当时世界变化太快，苏联共产党无法处理。把所有数据集中起来，重大决策都由一群官员决定，虽然能产生原子弹，但是无法造出苹果和维基
<br>
<br>
如今传统的民主政治正在逐渐失去控制，也提不出有意义的未来愿景，自由主义知识份子开始失去信仰，英国脱欧，Trump当选总统都证实了现在的人民已经对民主体制失去信心<br>
随着目前AI，大数据和算法的发展，未来可能以中国共产党为代表的集中式处理方案比美国民主社会为代表的分布式处理效率更高，未来社会可能是少部分人独裁的社会
<br><br>
随着生物科技的发展，未来阶层更加难以跨越，未来社会不同阶层可能不单单是社会地位，财富的区别，可能还会出现生理特征上的差别，富人和官员可能通过基因优化技术，从而培养出来的后代，天生就比穷人的后代更加聪明，健康，是完全生理上的不平等